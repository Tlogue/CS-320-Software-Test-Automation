Tyler Logue  
CS-320 Software Test Automation  
2/19/24  
Project Two 
Professor Tanisha

Project Two 
The three testing unit services implemented to align with the various software requirements requested were Contact, Task, and Appointment. I believed the functions implemented within the services for my code fully aligned with the software requirements that were requested. As the Contact Service focused primarily on updating, removing, inserting, and retrieving data continuously over time for a phone contact application. Where the Contact Class requirements request that the unique contact ID string be no longer than 10 characters for the contact's first name/last name and the contact ID must not be null and shall not be updated to ensure valid inputs. The contact object will have two required fields: a phone String field that must be exactly 10 digits/ the phone field must not be empty(null) and a required address field that must be no longer than 30 characters/address field shall not be empty(null). The Contact Service Requirements requested that the contact service add, delete, and update contacts with a unique ID for the four fields (First Name, Last Name, Number, and Address). 
The Task services requested focused on creating a task object that had a unique task ID String that was no longer than 10 characters and the task ID must not be empty/updatable. The Task object consists of two fields: a required name String field, which cannot exceed 20 characters in length, and a description field, which cannot exceed 50 characters and must not be empty. The description field is mandatory and should not accept empty input from the user. 
Lastly, the Appointment service requested that had appointment object that would require a unique appointment ID string that cannot be longer than 10 characters for input from the user. Also, the user's appointment ID shall not be null and shall not be updated. In the Appointment object, there will be an appointment Date field and its date cannot be in the past or be null. The appointment object will additionally have a required description String field that cannot contain any more than 50 characters or be null. Appointment Service Requirements were to add and delete appointments with a unique appointment ID. 
To ensure my code was technically sound I checked that each of my functions met the requirements listed for the services. Such as the ContactID not be null, if found to be true that it is empty for the ID then an illegal argument would be thrown. In our Appointment/Task, both had a field that would throw an illegal argument if more than 50 characters were used in the description length. To further ensure my code was efficient I utilized data algorithms of the vector to have a proper time complexity when runtime occurs for the program. After I ran and reviewed my J unit tests for the Appointment service recently it showed a total number of 6 runs, 0 errors, and failures. Here is a snippet of my code for the Contact and Appointment Class.
 Contact Code Snippet
if (contactId == null) { 
throw new IllegalArgumentException("ContactID cannot be null."); 
}
Appointment Code Snippet
public void setDescription(String description) 
{ 
if (description == null) { throw new IllegalArgumentException("Description cannot be null."); 
} 
if (description.length() > 50) { throw new IllegalArgumentException("Description cannot 	exceed 50 characters."); 
} 
this.description = description; 
} 
}

For this project, I employed the software testing technique of Unit Testing to help verify that the program ran as intended. Specifically, I created Three separate unit test services for Contact, Task, and Appointment that worked to handle the addition, update, and deletion of data while enforcing constraints.to make sure the data given matches the correct data that is expected to be received from the end user. 
A software testing technique that I did not integrate into this project was Acceptance testing, which is the testing technique for software to verify that it meets the product owner's and stakeholders' requirements. Another software testing technique that I did not apply was Regression testing which focuses on updating code, or new functions introduced to the code base to ensure that unintended behaviors or bugs are not seen when running the program. 
The practical uses and implications of Unit, Acceptance, and Regression testing for software development are impactful. Unit testing enables the project to help find errors and bugs seen early and throughout the software's development. While Acceptance testing can happen simultaneously, it will ensure that as developers we are building the product correctly to align with the product owners' goals. Lastly, Regression Testing allows the software product to work effectively, efficiently, and as intended over time when continuously updating the software. 
In acting as a software tester, I employed caution by trying my best to fully understand the test cases that should be implemented based on the requests given. Also, with the IDE, you can ensure there are a specific number of test cases and verify that it's functional as a Junit. For these test cases and for other ones that I work on in the future, I understand that I must be able to better create edge cases to design test cases correctly. It was important to appreciate the complexity and interrelationships as it helped to design the code for these Junit test cases. Also, I felt as if the Unit testing helped me focus better on understanding requirements and assessing how I should implement them within my code effectively thanks to the three service requirements I completed for homework. Finally, Java Brains website and its YouTube channel greatly influenced my ability to be able to write JUnit's tests for each of the services that I will provide a resource for at the bottom of the page.
I tried to eliminate bias in the review of my own code or for any assignment as I strongly believe that is a good way to hinder your own growth as a developer. As well I really try to look for any errors or bugs when I run the debugger in the IDE, as I know bad coding reflects you as a programmer. If any bugs or logic errors are found, I try my best to fix or find a solution by doing things such as surfing for documents online, stack overflow, and many other resources. If not, then I generally let my teachers know that there was a logic error or bug in my assignment that I was not able to fix.  
It is important to stay disciplined in my commitment to quality as a software engineering professional because I will hopefully be working for a client who will be paying for a product that I will be delivering. I will continue to practice good coding habits as the product created by you as a programmer reflects you in the field. It is crucial to practice not cutting corners when it comes to writing or testing code to ensure the product runs smoothly and as intended. Also, when going back to update or code, it will be even more difficult if you cut corners to understand how the base code operates including the functionalities within it.  
As a practitioner in the field, I plan to avoid technical debt by adopting several strategies to keep improving myself. First, I will continue to keep practicing coding until I make enough funds to go back to school for my Bachelors. Secondly, I will ensure that I stay up to date by using documents for libraries, data algorithms/structures, Leet code, and other resources to improve my coding. Thirdly I will try my best to write clean code that is up to coding standards including comments to ensure my code is easy to understand, maintain, and enhance for the future.
Resources
Java brains. (n.d.). Java Brains. https://javabrains.io/
